#include <avr/eeprom.h>

const uint8_t titleText[] = {
  0x00, 0xff, 0x81, 0xbf, 0xa0, 0xa0, 0xa0, 0xe0, 0x00, 0xff, 0x81, 0xb5, 0xb1, 0xff, 0x00,
  0x00, 0xff, 0x81, 0x9d, 0x9d, 0x49, 0x22, 0x1c, 0x00, 0xff, 0x89, 0x89, 0x4a, 0x34, 0x00,
  0x3c, 0x42, 0x99, 0x99, 0x42, 0x3c, 0x03, 0x05, 0x06, 0xf8, 0x80, 0xf8, 0x06, 0x05, 0x03,
  0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x1b, 0x19, 0x19, 0x1b, 0xfc, 0x00, 0xff, 0x81, 0x9d,
  0x9d, 0x49, 0x22, 0x1c, 0x00, 0x07, 0x19, 0x23, 0x4c, 0x88, 0x4c, 0x23, 0x19, 0x07, 0x00,
  0xff, 0x81, 0xb5, 0xb1, 0xb1, 0xff, 0x00, 0xff, 0x83, 0xe6, 0x0c, 0x38, 0xdf, 0x81, 0xff,
  0x00, 0x03, 0x01, 0xfd, 0x81, 0xfd, 0x01, 0x03, 0x00, 0xff, 0x81, 0xbf, 0xa0, 0xbf, 0x81,
  0xff, 0x00, 0xff, 0xf9, 0x19, 0x39, 0xf6, 0xe0, 0x00, 0xff, 0x81, 0xb5, 0xb1, 0xff, 0x00,
  0x00, 0xfe, 0xb3, 0xb5, 0xb5, 0x85, 0xfb, 0x00
};

void setup() {
  // We will be outputting PWM on PA3 on an 8-pin part PA3 - TCA0 WO0, pin 4 on 8-pin parts
  PORTMUX.CTRLC     = PORTMUX_TCA00_ALTERNATE_gc; // turn off PORTMUX, returning WO0 PORTMUX_TCA00_DEFAULT_gc for PA3. PORTMUX_TCA00_ALTERNATE_gc; for PA7
  takeOverTCA0();                               // this replaces disabling and resettng the timer, required previously.
  TCA0.SINGLE.CTRLB = (TCA_SINGLE_CMP0EN_bm | TCA_SINGLE_WGMODE_SINGLESLOPE_gc); // Single slope PWM mode, PWM on WO0
  TCA0.SINGLE.PER   = 255;                    // Count all the way up to (255) - 8-bit PWM. At 5MHz, this gives ~19.607kHz PWM
  TCA0.SINGLE.CMP0  = 115; // 45% duty cycle
  TCA0.SINGLE.CTRLA = TCA_SINGLE_ENABLE_bm; // enable the timer with no prescaler
  
  for (int x = 0; x < 128; x++) {
    eeprom_write_byte((uint8_t*)x, titleText[x]);
  }
}

void loop() {
  // put your main code here, to run repeatedly:
}
